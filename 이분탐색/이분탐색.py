'''
이분탐색의 종류에 대해 생각해보자.

1. 특정 값의 존재 여부 찾기

2. 중복이 가능한 배열에서 (정렬을 훼손하지 않으면서 삽입될 수 있는 위치의) 상한과 하한 찾기

고려해야 할 점은 무엇이 있을까? (참고로 여기서 a는 입력 배열이며 오름차순으로 정렬되어 있다고 가정)

1. 정렬 순서가 오름차순인지 내림차순인지
    알아서 잘 구현하면 됨 (하나에 대해서 구현할 줄 알면 다른 하나에 대해 구현하는 것은 쉬움)

2. s, e를 어떻게 설정할 것인지
    최초 호출 시 [0, len(a) - 1]에서 시작할 것인지, [0, len(a)]에서 시작할 것인지..

    전자의 경우가 구현하기 더 쉬울 것으로 보이므로 전자를 선택

2. base case를 어떻게 설정할지와 같이 생각

    일단 입력값 자체의 edge case에 대해 생각해보자.

    1) 빈 배열
        a = []
        최초에 s = 0, e = -1
        
        k를 찾는 경우 s > e 이므로 False 반환
        상한/하한을 찾는 경우 모두 s 반환

        빈 배열이 아니더라도, 결과적으로 s > e인 경우에 도달하도록 recursive case를 작성하면 될 듯.

    2) 1개 짜리 배열
        a = [t]
        최초에 s = 0, e = 0

        k를 찾는 경우 a[s] == k인지 검사 해야 함. (base case로 빼지 않아도 되어 보임)

        상한/하한을 찾는 경우에는.. 대소 비교가 필요해 보인다.
        다만 base case로 따로 빼야할지 아니면 일반화가 가능한지는 좀 더 생각을 해봐야 할 듯.

    따라서 s > e인 경우만 base case로 처리하는 것으로 일단 결정
    
3. mid를 어떻게 구할 것인지.
    mid = (s + e) // 2
    mid = (s + e + 1) // 2

    위와 같은 2가지 경우가 가능할 것으로 보인다.

    코드를 작성하면서 살펴보는 게 좋을 것 같다

'''

arr = [None] * 5

arr[0] = [0, 0, 0, 1, 1, 1, 2, 2, 2]
arr[1] = [0, 1, 2, 3, 4, 5, 6, 7, 8]
arr[2] = [0, 1]
arr[3] = [0]
arr[4] = []

def check(fun, k):
    print(f"=====function = {fun.__name__}=====")
    for a in arr:
        print(f"array = {a}, k = {k}")
        print(f"return = {fun(a, k, 0, len(a) - 1)}")


'''
A) 특정 값의 존재 여부 검사

s > e인 경우 False가 반환되도록 base case를 정의하고 나머지 경우를 적절히 구현
'''

def find(a, k, s, e):
    if s > e:
        return False
    mid = (s + e) // 2
    if a[mid] == k:
        return True
    elif a[mid] > k:
        return find(a, k, s, mid - 1)
    else:
        return find(a, k, mid + 1, e)
    
check(find, 1)

'''
B) 중복 배열에서 특정 값의 하한 찾기

마찬가지로 s > e 인 경우를 base case로 설정하고..

a[mid] > k인 경우 -> 왼쪽 탐색
a[mid] == k인 경우 -> 왼쪽 탐색
a[mid] < k인 경우 -> 오른쪽 탐색

여기서 왼쪽 구간을 탐색할 때 mid가 제외되는 이유가 언뜻 이해되지 않을 수 있다.
(물론 해당 코드에서 mid를 포함하는 것으로만 수정하면 무한 루프가 일어나긴 한다.)

제외된 mid가 실제로는 정답이라고 가정해보자.
그러면 [s, mid - 1]에 포함되는 원소들은 모두 k보다 작은 값들일 것이다.

그러면 결국 mid가 찾아지게 된다..
    정확히 따져보면, [s, mid - 1]를 검사하는 순간부터는 항상 [mid + 1, e]로 범위가 좁혀질 것이다.
    mid는 항상 구간에서 제외되므로 [e + 1, e]가 되는 순간까지 재귀호출 된다.
    이때 s = e + 1 > e가 되고, s를 반환하게 되면.. e가 mid - 1이었으므로 s는 mid와 동일한 값이 된다.

'''

def find_lower(a, k, s, e):
    if s > e:
        return s
    mid = (s + e) // 2
    if a[mid] >= k:
        return find_lower(a, k, s, mid - 1)
    else:
        return find_lower(a, k, mid + 1, e)


check(find_lower, 0)

'''
C) 중복 배열에서 특정 값의 상한 찾기

하한 찾기 함수와 비슷하게 구현하면 된다.

a[mid] > k인 경우 왼쪽 구간을 탐색한다.
a[mid] == k인 경우 오른쪽 구간을 탐색한다.
a[mid] < k인 경우 오른쪽 구간을 탐색한다.

이 함수도 마찬가지로 왼쪽 구간을 탐색할 때 mid가 제외되어도 상관없는 이유를 생각해보자.
(즉 자신보다 큰 값을 발견했을 때 mid를 제외한 왼쪽 구간을 탐색하지만, 실제로는 해당 위치가 정답일 수 있음.)

mid가 정답 위치인데 [s, mid - 1]를 호출한 경우, 해당 구간의 모든 원소는 k보다 같거나 작은 값이다.
결과적으로 [mid + 1, e]를 계속 호출하게 되는데.. [e + 1, e]가 되는 순간까지 호출된다.
결국 e + 1이 s로서 반환되는데.. s = e + 1 = mid이므로 정답 위치가 찾아진다.

'''

def find_upper(a, k, s, e):
    if s > e:
        return s
    mid = (s + e) // 2
    if a[mid] > k:
        return find_upper(a, k, s, mid - 1)
    else:
        return find_upper(a, k, mid + 1, e)

check(find_upper, 1)


'''
이분탐색을 사용하는 경우

1) 정렬된 배열에 대해 원소 찾기

2) 매개변수 탐색
    어떤 시점까지는 조건을 만족하다가, 어떤 시점부터는 조건을 만족하지 않을 때
    그 분기점을 찾기 위해 이분탐색을 사용할 수 있다.

    사실 1번과 다를 건 없지만, 문제에서 이것을 식별해내는 것이 중요
'''